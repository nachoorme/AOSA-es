\begin{aosachapter}{Jitsi}{s:jitsi}{Emil Ivov}
%Jitsi is an application that allows people to make video and voice
%calls, share their desktops, and exchange files and messages. More
%importantly it allows people to do this over a number of different
%protocols, ranging from the standardized XMPP (Extensible Messaging
%and Presence Protocol) and SIP (Session Initiation Protocol) to
%proprietary ones like Yahoo! and Windows Live Messenger (MSN).  It
%runs on Microsoft Windows, Apple Mac OS X, Linux, and FreeBSD\@. It is
%written mostly in Java but it also contains parts written in native
%code.  In this chapter, we'll look at Jitsi's OSGi-based architecture,
%see how it implements and manages protocols, and look back on what
%we've learned from building it.\footnote{To refer directly to the
%source as you read, download it from
%\url{http://jitsi.org/source}.  If you are using Eclipse or NetBeans,
%you can go to \url{http://jitsi.org/eclipse} or
%\url{http://jitsi.org/netbeans} for instructions on how configure
%them.}
Jitsi es una aplicación que permite a la gente realizar llamadas de voz y video,
compartir sus escritorios, e intercambiar ficheros y mensajes. Mas importante
aún es que permite realizar todo esto sobre una serie de diferentes protocolos,
que van desde los standard XMMP (Extensible Messaging and Presence
Protocol) y SIP (Session Initiation Protocol) a los propietarios como Yahoo!
y Windows Live Messenger (MSN). Funciona sobre Microsoft Windows, Apple
Mac OS X, Linux y FreeBSD\@. Esta escrito en su mayor parte en Java pero también
contiene partes en código nativo. En este capitulo, veremos como Jitsi esta
basado en la arquitectura OSGi, como implementa y gestiona los protocolos,
y echaremos la vista atrás para ver que hemos aprendido durante su
desarrollo.\footnote{Para acceder directamente al código que tu lees, descargarlo
desde \url{http://jitsi.org/source}. Si estas usando Eclipse o Netbeans, 
puedes visitar \url{http://jitsi.org/eclipse} o \url{http://jitsi.org/netbeans} 
donde encontrarás información acerca de como configurarlos.}


%\begin{aosasect1}{Designing Jitsi}
\begin{aosasect1}{El diseño de Jitsi}

%The three most important constraints that we had to keep in mind when
%designing Jitsi (at the time called SIP Communicator) were
%multi-protocol support, cross-platform operation, and
%developer-friendliness.
Las tres restricciones más importantes que hemos tenido en mente durante el 
diseño de Jitsi (antes llamado SIP Communicator) fueron el soporte multi-protocolo,
el funcionamiento multi-plataforma, y el desarrollo amigable.

%From a developer's perspective, being multi-protocol comes down to
%having a common interface for all protocols. In other words, when a
%user sends a message, our graphical user interface needs to always
%call the same \code{sendMessage} method regardless of whether the
%currently selected protocol actually uses a method called
%\code{sendXmppMessage} or \code{sendSipMsg}.
Desde la perspectiva de un desarrollador, ser multi-protocolo se reduce a tener
una interfaz común para todos los protocolos. En otras palabras, cuando un usuario
envía un mensaje, nuestra interfaz gráfica de usuario necesita llamar siempre 
a el mismo método \code{sendMessage} sin tener en cuenta si el protocolo seleccionado 
actualmente usa un método llamado \code{sendXmppMessage} o \code{sendSipMsg}.

%The fact that most of our code is written in Java satisfies, to a
%large degree, our second constraint: cross-platform operation. Still,
%there are things that the Java Runtime Environment (JRE) does not
%support or does not do the way we'd like it to, such as capturing
%video from your webcam. Therefore, we need to use DirectShow on
%Windows, QTKit on Mac OS X, and Video for Linux 2 on Linux. Just as
%with protocols, the parts of the code that control video calls cannot
%be bothered with these details (they are complicated enough as it is).
El hecho de que la mayor parte de nuestro código este escrito en Java satisface,
en gran medida, nuestra segunda restricción: soporte multi-plataforma. Sin embargo,
hay cosas que el Java Runtime Environment (JRE) no soporta o no permite hacerlo
de la forma que a nosotros nos gustaría, como la captura de video desde su webcam.
Por lo tanto, nosotros necesitamos usar DirectShow en Windows, QTKit en Mac OS X,
y Video for Linux 2 en Linux. Al igual que con los protocolos, las partes del
código que controlan las llamadas de video no puede ser molestadas con estos
detalles (ya son lo suficientemente complicadas por si mismas).

%Finally, being developer-friendly means that it should be easy for
%people to add new features. There are millions of people using VoIP
%today in thousands of different ways; various service providers and
%server vendors come up with different use cases and ideas about new
%features. We have to make sure that it is easy for them to use Jitsi
%the way they want.  Someone who needs to add something new should have
%to read and understand only those parts of the project they are
%modifying or extending.  Similarly, one person's changes should have
%as little impact as possible on everyone else's work.
Finalmente, tener un desarrollo amigable significa que debe ser fácil para la gente añadir 
nuevas características. Hoy hay millones de personas usando VoIP de cientos
de formas diferentes; varios proveedores de servicios y vendedores de servidores
aparecen con diferentes casos de uso e ideas sobre nuevas características. Nosotros
tenemos que asegurarnos que es fácil para ellos usar Jitsi de la forma que ellos
quieren. Alguien que necesita añadir algo nuevo debe tener que leer y comprender 
sólo aquellas partes del proyecto está modificando o ampliando. De la misma manera,
los cambios de una persona deben tener el menor impacto posible sobre el resto de trabajos.

%To sum up, we needed an environment where different parts of the code
%are relatively independent from each other. It had to be possible to
%easily replace some parts depending on the operating system; have
%others, like protocols, run in parallel and yet act the same; and it
%had to be possible to completely rewrite any one of those parts and
%have the rest of the code work without any changes.  Finally, we
%wanted the ability to easily switch parts on and off, as well as the
%ability to download plugins over the Internet to our list.
En resumen, nosotros necesitamos un entorno donde las diferentes partes del código
son relativamente independientes entre sí. Tiene que ser posible remplazar fácilmente
algunas partes dependientes del sistema operativo; tener otras, como los protocolos,
corriendo en paralelo y sin embargo, actuando de la mima manera; y tiene que ser
posible reescribir completamente cualquiera de estas partes sin tener que modificar 
el resto del código. Finalmente, nosotros queríamos la capacidad de activar y desactivar 
fácilmente las piezas, así como la capacidad de descargar plugins a través de Internet 
desde nuestra lista.

%We briefly considered writing our own framework, but soon dropped the
%idea. We were itching to start writing VoIP and IM code as soon as
%possible, and spending a couple of months on a plugin framework
%didn't seem that exciting. Someone suggested OSGi, and it seemed to be
%the perfect fit.
Hemos considerado brevemente escribir nuestro propio framework, pero pronto se abandonó 
la idea. Estábamos ansiosos por empezar a escribir código de VoIP e IM tan pronto como fuera
posible, y pasar un par de meses con un plugin framework no parecía tan emocionante.
Alguien sugirió OSGi, y parecía ajustarse perfectamente.

\end{aosasect1}

%\begin{aosasect1}{Jitsi and the OSGi Framework}
\begin{aosasect1}{Jitsi y el Framework OSGi}

%People have written entire books about OSGi, so we're not going to go
%over everything the framework stands for. Instead we will only explain
%what it gives us and the way we use it in Jitsi.
La gente ha escrito libros enteros acerca de OSGi, así que nosotros no vamos a 
cubrir todos los aspectos sobre este framework. En su lugar solo explicaremos
lo que nos aporta y como lo usamos en Jitsi.

%Above everything else, OSGi is about modules.  Features in OSGi
%applications are separated into bundles. An OSGi bundle is little more
%than a regular JAR file like the ones used to distribute Java
%libraries and applications. Jitsi is a collection of such
%bundles. There is one responsible for connecting to Windows Live
%Messenger, another one that does XMPP, yet another one that handles
%the GUI, and so on.  All these bundles run together in an environment
%provided, in our case, by Apache Felix, an open source OSGi
%implementation.
Por encima de todo, OSGi es un sistema de módulos. Las diferentes características
en las aplicaciones OSGi son separadas en bundles. Un bundle OSGi es un poco mas
que un común archivo JAR como los utilizados para distribuir las librerías
y aplicaciones Java. Jitsi es una colección de estos bundles. Hay uno responsable
de la conexión a través de Windows Live Messenger, otro que utiliza XMPP, así mismo 
otro bundle se encarga de la GUI y así sucesivamente. Todos estos bundles se
ejecutan juntos en un entorno proporcionado, en nuestro caso, por Apache Felix,
una implementación de código abierto de OSGi.

%All these modules need to work together. The GUI bundle needs to send
%messages via the protocol bundles, which in turn need to store them
%via the bundles handling message history. This is what OSGi services
%are for: they represent the part of a bundle that is visible to
%everyone else. An OSGi service is most often a group of Java
%interfaces that allow use of a specific functionality like logging,
%sending messages over the network, or retrieving the list of recent
%calls. The classes that actually implement the functionality are known
%as a service implementation. Most of them carry the name of the
%service interface they implement, with an ``Impl'' suffix at the end
%(e.g., \code{ConfigurationServiceImpl}). The OSGi framework allows
%developers to hide service implementations and make sure that they are
%never visible outside the bundle they are in. This way, other bundles
%can only use them through the service interfaces.
Todos estos módulos necesitan trabajar juntos. El bundle GUI necesita
enviar mensajes a través de los bundles de protocolo, que a su vez 
necesitan para guardar dichos mensajes los bundles de manejo del historial
de mensajes. Esta es la misión de los servicios OSGi: estos servicios
representan la parte de un bundle que es visible a todos los demás.
Un servicio OSGi es comúnmente un grupo de interfaces Java que permiten
el uso de una funcionalidad especifica como loggin, envio de mensajes
sobre la red, o recuperación de la lista de llamadas recientes. Las clases
que realmente implementan la funcionalidad se conocen como la implementación
del servicio. La mayoría de ellas llevan el nombre de la interfaz del servicio
que implementan, con un sufijo ``Impl'' al final (e.g., \code{ConfigurationServiceImpl}).
El framework OSGi permite a los desarrolladores ocultar la implementación
de los servicios y asegurase de que nunca es visible desde fuera del bundle
al que pertenecen. De esta manera, otros bundles solo pueden usarlos a través
de las interfaces de los servicios.

%Most bundles also have activators. Activators are simple interfaces
%that define a \code{start} and a \code{stop} method. Every time Felix
%loads or removes a bundle in Jitsi, it calls these methods so that the
%bundle can prepare to run or shut down. When calling these methods
%Felix passes them a parameter called BundleContext. The BundleContext
%gives bundles a way to connect to the OSGi environment. This way they
%can discover whatever OSGi service they need to use, or register one
%themselves (\aosafigref{fig.jit.osgi}).
La mayoria de los bundles tambien tienen activadores. Los activadores
son simples interfaces que definen un metodo \code{start} y un metodo
\code{stop}. Cada vez que Felix carga o elimina un bundle de Jitsi, llama
a estos metodo para que el bundle pueda preparar su ejecución o detención.
Cuando llama a estos métodos Felix les pasa un parametro llamado BundleContext.
El BundleContext proporciona a los bundles una forma de conectarse al
entorno OSGi. De esta manera se pude descubrir cualquier servicio OSGi
que necesiten utilizar, o registrar (\aosafigref{fig.jit.osgi}).

\aosafigure{../images/jitsi/OSGI.eps}{OSGi Bundle Activation}{fig.jit.osgi}

%So let's see how this actually works.  Imagine a service that
%persistently stores and retrieves properties. In Jitsi this is what we
%call the ConfigurationService and it looks like this:
Así que vamos a ver cómo funciona realmente. Imagina un servicio almacena y
recupera propiedades. En Jitsi esto es lo que nosotros llamamos el
ConfigurationService y es paracido a esto:

\pagebreak 

\begin{verbatim}
package net.java.sip.communicator.service.configuration;

public interface ConfigurationService
{
  public void setProperty(String propertyName, Object property);
  public Object getProperty(String propertyName);
}
\end{verbatim}

%A very simple implementation of the \code{ConfigurationService} looks like
%this:
Una implementación muy simple de ConfigurationService se parece a esto:

\begin{verbatim}
package net.java.sip.communicator.impl.configuration;

import java.util.*;
import net.java.sip.communicator.service.configuration.*;

public class ConfigurationServiceImpl implements ConfigurationService
{
  private final Properties properties = new Properties();

  public Object getProperty(String name)
  {
    return properties.get(name);
  }

  public void setProperty(String name, Object value)
  {
    properties.setProperty(name, value.toString());
  }
}
\end{verbatim}

%\noindent Notice how the service is defined in the
%\code{net.java.sip.communicator.\emph{service}} package, while the
%implementation is in \code{net.java.sip.communicator.\emph{impl}}. All
%services and implementations in Jitsi are separated under these two
%packages. OSGi allows bundles to only make some packages visible
%outside their own JAR, so the separation makes it easier for bundles
%to only \emph{export} their service packages and keep their
%implementations hidden.
\noindent Observa como el servicio se define en el paquete
\code{net.java.sip.communicator.\emph{service}}, mientras
que la implementación esta en \code{net.java.sip.communicator.\emph{impl}}
Todos los servicios e implementaciones en Jitsi están separados en
estos dos paquetes. OSGi permite solo a algunos paquetes del bundle
ser visibles desde fuera de su propio JAR, por lo que esta separación
hace mas fácil poder \emph{exportar} únicamente los paquetes de servicio
manteniendo sus implementaciones ocultas.

%The last thing we need to do so that people can start using our
%implementation is to register it in the \code{BundleContext} and
%indicate that it provides an implementation of the
%\code{ConfigurationService}. Here's how this happens:
La última cosa que necesitamos hacer para que la gente puede empezar a utilizar 
nuestra complementación es registrarla en el \code{BundleContext} e indicar que 
se proporciona una implementación de el \code{ConfigurationService}. Aquí esta
como sucede esto:

\begin{verbatim}
package net.java.sip.communicator.impl.configuration;

import org.osgi.framework.*;
import net.java.sip.communicator.service.configuration;

public class ConfigActivator implements BundleActivator
{
  public void start(BundleContext bc) throws Exception
  {
    bc.registerService(ConfigurationService.class.getName(), // service name
         new ConfigurationServiceImpl(), // service implementation
         null);
  }
}
\end{verbatim}

%\noindent Once the \code{ConfigurationServiceImpl} class is registered in the
%\code{BundleContext}, other bundles can start using it. Here's an
%example showing how some random bundle can use our configuration
%service:
\noindent  Una vez que la clase \code{ConfigurationServiceImpl} es registrada
en el \code{BundleContext}, otros bundles pueden comenzar a utilizarla.
Aqui está un ejemplo que muestra como algun bundle aleatorio puede
usar nuestro servicio de configuración:

\begin{verbatim}
package net.java.sip.communicator.plugin.randombundle;

import org.osgi.framework.*;
import net.java.sip.communicator.service.configuration.*;

public class RandomBundleActivator implements BundleActivator
{
  public void start(BundleContext bc) throws Exception
  {
    ServiceReference cRef = bc.getServiceReference(
                              ConfigurationService.class.getName());
    configService = (ConfigurationService) bc.getService(cRef);

    // And that's all! We have a reference to the service implementation
    // and we are ready to start saving properties:
    configService.setProperty("propertyName", "propertyValue");
  }
}
\end{verbatim}

%\noindent Once again, notice the package. In
%\code{net.java.sip.communicator.plugin} we keep bundles that use
%services defined by others but that neither export nor implement any
%themselves. Configuration forms are a good example of such plugins:
%They are additions to the Jitsi user interface that allow users to
%configure certain aspects of the application. When users change
%preferences, configuration forms interact with the
%\code{ConfigurationService} or directly with the bundles responsible
%for a feature. However, none of the other bundles ever need to
%interact with them in any way (\aosafigref{fig.jit.pkgs}).
\noindent Una vez mas, observa el paquete. En 
\code{net.java.sip.communicator.plugin} nosotros mantenemos los bundles
que usan servicios definidos por otros, pero ellos no son exportados
ni implementa ninguno servicio. Los formularios de configuración son un buen
ejemplo de estos plugins: Ellos son añadidos al interfaz de usuario de Jitsi
que permite a los usuarios configurar ciertos aspectos de la aplicación.
Cuando el usuario cambia las preferencias, los formularios de configuración
interactuan con \code{ConfigurationService} o directamente con los bundles 
responsables de una característica. Sin embargo, ninguno de los otros bundles
tendrán nunca que interactuar con ellos de ninguna manera (\aosafigref{fig.jit.pkgs}).

\aosafigure[250pt]{../images/jitsi/PKGs.eps}{Service Structure}{fig.jit.pkgs}

\end{aosasect1}

%\begin{aosasect1}{Building and Running a Bundle}
\begin{aosasect1}{Construcción y Ejecución de un Bundle}

%Now that we've seen how to write the code in a bundle, it's time to
%talk about packaging. When running, all bundles need to indicate three
%different things to the OSGi environment: the Java packages they make
%available to others (i.e. exported packages), the ones that they would
%like to use from others (i.e. imported packages), and the name of
%their BundleActivator class. Bundles do this through the manifest of
%the JAR file that they will be deployed in.
Ahora que hemos visto como escribir el codigo en un bundle, es el momento
de hablar del empaquetado. Durante la ejecución, todos los bundles necesitan indicar
tres cosas diferentes a el entorno OSGi: los paquetes Java que ellos hacen disponibles
a otros (i.e. paquetes exportados), los que les gutaria usar de otros
(i.e paquetes importados), y el nombre de su clase BundleActivator. Los bundles
hacen esto a través de el manifest del archivo JAR en el que ellos seran desplegados.

%For the \code{ConfigurationService} that we defined above, the
%manifest file could look like this:
Para el \code{ConfigurationService} que nosotros hemos definido antes,
el fichero manifest podria ser parecido a esto:

\begin{verbatim}
Bundle-Activator: net.java.sip.communicator.impl.configuration.ConfigActivator
Bundle-Name: Configuration Service Implementation
Bundle-Description: A bundle that offers configuration utilities
Bundle-Vendor: jitsi.org
Bundle-Version: 0.0.1
System-Bundle: yes
Import-Package: org.osgi.framework,
Export-Package: net.java.sip.communicator.service.configuration
\end{verbatim}

%After creating the JAR manifest, we are ready to create the bundle
%itself. In Jitsi we use Apache Ant to handle all build-related
%tasks. In order to add a bundle to the Jitsi build process, you need
%to edit the \code{build.xml} file in the root directory of the
%project.  Bundle JARs are created at the bottom of the
%\code{build.xml} file, with \code{bundle-xxx} targets. In order to
%build our configuration service we need the following:
Después de crear el manifest del JAR, nosotros estamos listos para crear el
propio bundle. En Jitsi nosotros usamos Apache Ant para manejar todas las tareas
relacionadas con la construcción. Con el objetivo de agregar un bundle al proceso
de construcción de Jisti, usted necesitas editar el fichero \code{build.xml} en
la raíz del directorio del proyecto. Los paquetes JAR se crean en la parte inferior
del archivo \code{build.xml} con los targets \code{bundle-xxx}. Para construir
nuestro servicio de configuración nosotros necesitamos lo siguiente:

\begin{verbatim}
<target name="bundle-configuration">
  <jar destfile="${bundles.dest}/configuration.jar" manifest=
    "${src}/net/java/sip/communicator/impl/configuration/conf.manifest.mf" >

    <zipfileset dir="${dest}/net/java/sip/communicator/service/configuration"
        prefix="net/java/sip/communicator/service/configuration"/>
    <zipfileset dir="${dest}/net/java/sip/communicator/impl/configuration"
        prefix="net/java/sip/communicator/impl/configuration" />
  </jar>
</target>
\end{verbatim}

%As you can see, the Ant target simply creates a JAR file using our
%configuration manifest, and adds to it the configuration packages from
%the \code{service} and \code{impl} hierarchies. Now the only thing
%that we need to do is to make Felix load it.
Como puede ver, el target de Ant simplemente crea un archivo JAR utilizando
nuestro manifest de configuración, y le añade los paquetes de configuración
desde las jerarquías \code{service} y \code{impl}. Ahora lo único que necesitamos
es hacer que Felix lo cargue.

%We already mentioned that Jitsi is merely a collection of OSGi
%bundles. When a user executes the application, they actually start
%Felix with a list of bundles that it needs to load.  You can find that
%list in our \code{lib} directory, inside a file called
%\code{felix.client.run.properties}. Felix starts bundles in the order
%defined by start levels: All those within a particular level are
%guaranteed to complete before bundles in subsequent levels start
%loading. Although you can't see this in the example code above, our
%configuration service stores properties in files so it needs to use
%our \emph{FileAccessService}, shipped within the \code{fileaccess.jar}
%file. We'll therefore make sure that the ConfigurationService starts
%after the FileAccessService:
Nosotros ya mencionamos que Jitsi es simplemente un colección de bundles OSGi.
Cuando un usuario ejecuta la aplicación, ellos realmente inician Felix con una
lista de bundles que se deben cargar. Usted puede encontrar esta lista en nuestro
directorio \code{lib}, dentro un archivo llamado \code{felix.client.run.properties}.
Felix inicia los bundles en el orden definido por los niveles de inicio. Todos aquellos
que se encuentran dentro de un nivel particular esta garantizado que se completan antes
de que los bundles de niveles inferiores comiencen a cargarse. Aunque no se
puede ver en el código del ejemplo anterior, nuestro servicio de configuración
almacena propiedades en archivos así que necesita usar nuestro \emph{FileAccessService},
que se encuentra dentro del archivo \code{fileaccess.jar}. Por lo tanto nos aseguraremos
de que ConfigurationService se inicia después que el FileAccessService:

\begin{verbatim}
...
felix.auto.start.30= \
  reference:file:sc-bundles/fileaccess.jar

felix.auto.start.40= \
  reference:file:sc-bundles/configuration.jar \
  reference:file:sc-bundles/jmdnslib.jar \
  reference:file:sc-bundles/provdisc.jar \
...
\end{verbatim}

%If you look at the \code{felix.client.run.properties} file, you'll see
%a list of packages at the beginning:
Si se fijas en el archivo \code{felix.client.run.properties}, usted verá una lista de 
paquetes al comienzo:

\begin{verbatim}
org.osgi.framework.system.packages.extra= \
  apple.awt; \
  com.apple.cocoa.application; \
  com.apple.cocoa.foundation; \
  com.apple.eawt; \
...
\end{verbatim}

%\noindent The list tells Felix what packages it needs to make available to
%bundles from the system classpath. This means that packages that are
%on this list can be imported by bundles (i.e. added to their
%\emph{Import-Package} manifest header) without any being exported by
%any other bundle. The list mostly contains packages that come from
%OS-specific JRE parts, and Jitsi developers rarely need to add new
%ones to it; in most cases packages are made available by bundles.
\noindent Esta lista le dice a Felix que paquetes necesita que estén disponibles
para los bundles desde el classpath del sistema. Esto significa que los paquetes
que están en esta lista pueden ser importados por bundles (i.e añadiéndolos a
la \emph{Import-Package} cabecera del manifest) sin tener que ser exportados
por cualquier otro bundle. La lista contiene principalmente paquetes que vienen
desde otras partes del JRE especificas del sistema operativo, y los desarrolladores de
Jisti rara vez tienen que añadir otras nuevas; en la mayoría de los casos los
paquetes están disponibles para los bundles.

\end{aosasect1}

%\begin{aosasect1}{Protocol Provider Service}
\begin{aosasect1}{Servicio Proveedor de Protocolo}

%The \code{ProtocolProviderService} in Jitsi defines the way all
%protocol implementations behave. It is the interface that other
%bundles (like the user interface) use when they need to send and
%receive messages, make calls, and share files through the networks
%that Jitsi connects to.
El \code{ProtocolProviderService} en Jitsi define la forma en que
todas las implementaciones de protocolos se comportan. Es la interfaz
que otros bundles (como las interfaz de usuario) utilizan cuando necesitan
enviar y recibir mensajes, realizar llamadas, y compartir archivos a través
de las redes que se conectan a Jitsi.

%The protocol service interfaces can all be found under the
%\path{net.java.sip.communicator.service.protocol} package.  There are
%multiple implementations of the service, one per supported protocol,
%and all are stored in
%\code{net.java.sip.communicator.impl.protocol.\-protocol\_name}.
Las interfaces de servicio de protocolo se pueden encontrar bajo el paquete
\path{net.java.sip.communicator.service.protocol}. Hay múltiples implementaciones
de el servicio, una por protocolo soportado, y todas se almacenan en 
\code{net.java.sip.communicator.impl.protocol.\-protocol\_name}.

%Let's start with the \code{service.protocol} directory. The most
%prominent piece is the \emph{ProtocolProviderService} interface.
%Whenever someone needs to perform a protocol-related task, they have
%to look up an implementation of that service in the
%\code{BundleContext}. The service and its implementations allow Jitsi
%to connect to any of the supported networks, to retrieve the connection
%status and details, and most importantly to obtain references to the
%classes that implement the actual communications tasks like chatting
%and making calls.
Vamos a empezar con el directorio \code{service.protocol}. La pieza
mas destacada es la interfaz \emph{ProtocolProviderService}. Cada vez
que alguien tiene que realizar una tarea relacionada con los protocolos,
tiene que buscar una implementación de ese servicio en el \code{BundleContext}.
El servicio y su complementación permiten a Jitsi conectarse a cualquiera de
las redes soportadas, para recuperar el estado y los detalles de la conexión,
y lo mas importante para obtener referencias a las clases que que implementa
las actuales tareas de comunicación como el chat y las realización de llamadas.

\begin{aosasect2}{Colecciones de Operaciones}

%As we mentioned earlier, the \code{ProtocolProviderService} needs to
%leverage the various communication protocols and their
%differences. While this is particularly simple for features that all
%protocols share, like sending a message, things get trickier for tasks
%that only some protocols support. Sometimes these differences come
%from the service itself: For example, most of the SIP services out
%there do not support server-stored contact lists, while this is a
%relatively well-supported feature with all other protocols. MSN and
%AIM are another good example: at one time neither of them offered the
%ability to send messages to offline users, while everyone else
%did. (This has since changed.)
Como hemos mencionado anteriormente, \code{ProtocolProviderService} necesita
aprovecharse de varios protocolos de comunicación y de sus diferencias.
Si bien esto es particularmente sencillo para las características que comparten
todos los protocolos, como el envío de un mensaje, las cosas se ponen más difíciles
para las tareas que sólo algunos protocolos soportan. A veces, estas diferencias
provienen del propio servicio: Por ejemplo, la mayoría de los servicios SIP que
hay no soportan el almacenamiento de listas de contactos en el servidor, mientras
que esta es una característica relativamente bien soportada por todos los otros protocolos.
MSN y AIM son otro buen ejemplo: ninguno de ellos ofrece la posibilidad de enviar
mensajes a usuarios desconectados, mientras que todos los demás lo hacen.(Esto
ha cambiado desde entonces.)

%The bottom line is our \code{ProtocolProviderService} needs to have a
%way of handling these differences so that other bundles, like the GUI,
%act accordingly; there's no point in adding a call button to an AIM
%contact if there's no way to actually make a call.
El resultado final es que nuestro \code{ProtocolProviderService} necesita
tener una manera de manejar estas diferencias para que otros bundles,
como la GUI, actuen en consecuencia; No tiene sentido añadir un boton de
llamada para un contacto AIM si en ese momento no puede realizar una llamada.

%OperationSets to the rescue
%(\aosafigref{fig.jit.ops}). Unsurprisingly, they are sets of
%operations, and provide the interface that Jitsi bundles use to
%control the protocol implementations. The methods that you find in an
%operation set interface are all related to a particular feature.
%\emph{OperationSetBasicInstantMessaging}, for instance, contains
%methods for creating and sending instant messages, and registering
%listeners that allow Jitsi to retrieve messages it receives. Another
%example, \emph{OperationSetPresence}, has methods for querying the
%status of the contacts on your list and setting a status for
%yourself. So when the GUI updates the status it shows for a contact,
%or sends a message to a contact, it is first able to ask the
%corresponding provider whether they support presence and
%messaging. The methods that \code{ProtocolProviderService} defines for
%that purpose are:
OperationSets viene al rescate (\aosafigref{fig.jit.ops}). Como era de esperar,
se trata de conjuntos de operaciones, que proporcionan la interfaz que los bundles
de Jitsi utilizan para controlar la implementación de los protocolos. Los métodos que tu
encuentras en una interfaz de colección de operación están relacionados con una
característica particular. \emph{OperationSetBasicInstantMessaging}, por ejemplo,
contiene métodos para crear y enviar mensajes instantáneos, y registrar listeners que
permitan a Jitsi recuperar los mensajes que recibe. Otro ejemplo es \emph{OperationSetPresence},
que tiene métodos para consultar el estado de los contactos en tu lista y establecer tu propio estado.
Así que cuando la GUI actualiza el estado de un contacto, o envía mensajes a un contacto,
es el primero en solicitar al proveedor correspondiente si soporta la presencia y la mensajería.
Los métodos que \code{ProtocolProviderService} define para tal fin son:

\begin{verbatim}
public Map<String, OperationSet> getSupportedOperationSets();
public <T extends OperationSet> T getOperationSet(Class<T> opsetClass);
\end{verbatim}

%OperationSets have to be designed so that it is unlikely that a new
%protocol we add has support for only some of the operations defined in
%an OperationSet. For example, some protocols do not support server-stored
%contact lists even though they allow users to query each other's status. 
%Therefore, rather than combining the presence management and buddy list 
%retrieval features in \code{OperationSetPresence}, we also defined an
%\code{OperationSetPersistentPresence} which is only used with protocols
%that can store contacts online. On the other hand, we have yet to come 
%across a protocol that only allows sending messages without receiving 
%any, which is why things like sending and receiving messages can be 
%safely combined.
OperationSets ha sido diseñado de tal manera que es improbable que un nuevo protocolo
que nosotros añadamos tenga soporte solo para algunas de las operaciones definidas
en un OperationSet. Por ejemplo, algunos protocolos no soportan el almacenamiento
de listas de contactos en el servidor a pesar de que permiten a los usuarios consultar
sus respectivos estados. Por lo tanto, en lugar de combinar las características de
la gestión de la presencia y la recuperación de la lista de amigos en \code{OperationSetPresence},
nosotros también definimos un \code{OperationSetPersistentPresence} que solo es usado
con protocolos que pueden almacenar los contactos en linea. Por otro lado, todavía
hemos llegado a través de un protocolo que únicamente permite enviar mensajes pero
no recibirlos, que es la razón por la cual enviar y recibir mensajes puede ser 
combinado de forma segura.

\aosafigureTop{../images/jitsi/OperationSets.eps}{Operation Sets}{fig.jit.ops}

\end{aosasect2}

%\begin{aosasect2}{Accounts, Factories and Provider Instances}
\begin{aosasect2}{Cuentas, Factorias y Proveedor de Instancias}

%An important characteristic of the \code{ProtocolProviderService} is
%that one instance corresponds to one protocol account. Therefore, at
%any given time you have as many service implementations in the
%\code{BundleContext} as you have accounts registered by the user.
Una caracteristica importante de \code{ProtocolProviderService} es
que una instancia se corresponde con una cuenta de protocolo. Por lo
tanto, en un momento dado tu tienes tantas implementaciones de servicios
en el \code{BundleContext} como cuentas registradas por el usuario.

%At this point you may be wondering who creates and registers the
%protocol providers.  There are two different entities involved. First,
%there is \code{ProtocolProviderFactory}. This is the service that
%allows other bundles to instantiate providers and then registers them
%as services. There is one factory per protocol and every factory is
%responsible for creating providers for that particular
%protocol. Factory implementations are stored with the rest of the
%protocol internals. For SIP, for example we have
%\code{net.java.sip.communicator.impl.protocol.sip.ProtocolProviderFactorySipImpl}.
En este punto puedes estar preguntandote quien crea y registra los
proveedores de protocolo. Hay dos entidades diferentes involucradas.
En primer lugar, esta \code{ProtocolProviderFactory}. Este es el servicio
que permite a otros bundles instanciar proveedores y registrarlos como 
servicios. Hay una factoria por protocolo y cada factoria es responsable
de le creacion de proveedores para ese protocolo particular. Las implementaciones
de las factorias son almacenadas con el resto de protocolos internos. Para
SIP, por ejemplo nosotros tenemos
\code{net.java.sip.communicator.impl.protocol.sip.ProtocolProviderFactorySipImpl}.

%The second entity involved in account creation is the protocol wizard.
%Unlike factories, wizards are separated from the rest of the protocol
%implementation because they involve the graphical user interface. The
%wizard that allows users to create SIP accounts, for example, can be
%found in \code{net.java.sip.communicator.plugin.sipaccregwizz}.
La sengunda entidad envuelta en la creacion de la cuenta es el asistente
de protocolo. A diferencia de las factorias, los asistentes son separados
del resto de las implementaciones de protocolos porque ellos involucran
la interfaz grafica de usuario. El asistente que permite a los usuarios
crear cuentas SIP, por ejemplo, se puede encontrar en
\code{net.java.sip.communicator.plugin.sipaccregwizz}.

\end{aosasect2}

\end{aosasect1}

%\begin{aosasect1}{Media Service}
\begin{aosasect1}{Servicios de comunicación}

%When working with real-time communication over IP, there is one
%important thing to understand: protocols like SIP and XMPP, while
%recognized by many as the most common VoIP protocols, are not the ones
%that actually move voice and video over the Internet. This task is
%handled by the Real-time Transport Protocol (RTP).  SIP and XMPP are
%only responsible for preparing everything that RTP needs, like
%determining the address where RTP packets need to be sent and
%negotiating the format that audio and video need to be encoded in
%(i.e. codec), etc. They also take care of things like locating users,
%maintaining their presence, making the phones ring, and many
%others. This is why protocols like SIP and XMPP are often referred to
%as signalling protocols.
Cuando trabajamos con comunicación en tiempo real sobre IP, hay una
cosa importante que debemos entender: protocolos como SIP y XMPP,
aunque reconocido por muchos como los protocolos de VoIP más comunes,
no son los que mueven realmente la voz y vídeo a través de Internet.
Esta tarea es manejada por el Real-time Transport Protocolo (RTP).
SIP y XMPP solo son responsables de la preparación de todo
lo que necesita RTP, como el calculo de la dirección de destino
donde los paquetes RTP deben ser enviados y la negociación del formato
de audio y vídeo en el que deben ser codificados (i.e. codec), etc.
También se ocupan de cosas como la localización de usuarios,
el mantenimiento de su presencia, hacer sonar los teléfonos, y otras
muchas cosas. Esta es la razón por la cual a los protocolos SIP y XMPP
se les conoce como protocolos de señalización.

%What does this mean in the context of Jitsi? Well, first of all it
%means that you are not going to find any code manipulating audio or
%video flows in either the \emph{sip} or \emph{jabber} jitsi packages.
%This kind of code lives in our MediaService. The MediaService and its
%implementation are located in
%\path{net.java.sip.communicator.service.neomedia} and
%\path{net.java.sip.communicator.impl.neomedia}.
Que significa esto en el contexto de Jitsi? Bueno, primero de todo lo
que significa es que usted no encontrara ningún código de manipulación
de los flujos de audio o vídeo, tanto en los paquetes \emph{sip} como
el los de \emph{jabber} jitsi. Este tipo de código se encuentra en
nuestro MediaService. El MediaService y sus implementaciones se encuentran
localizadas en \path{net.java.sip.communicator.service.neomedia} and
\path{net.java.sip.communicator.impl.neomedia}.

%\begin{aosabox}{Why ``neomedia''?}
\begin{aosabox}{¿Por que ``neomedia''?}

%The ``neo'' in the neomedia package name indicates that it replaces a
%similar package that we used originally and that we then had to
%completely rewrite. This is actually how we came up with one of our
%rules of thumb: It is hardly ever worth it to spend a lot of time
%designing an application to be 100\% future-proof. There is simply no
%way of taking everything into account, so you are bound to have to
%make changes later anyway. Besides, it is quite likely that a
%painstaking design phase will introduce complexities that you will
%never need because the scenarios you prepared for never happen.
El ``neo'' en el nombre del paquete neomedia indica que remplaza
a un paquete similar que nosotros utilizamos originalmente y que
luego tuvimos que reescribir completamente. Esta es realmente
la forma de como se nos ocurrió una de nuestras reglas de oro:
Casi nunca vale la pena gastar un montón de tiempo en el diseño de
una aplicación que sea 100\% a prueba de futuro. Simplemente no
hay manera de tener todo en cuenta, por lo que usted esta obligado
a tener que realizar cambios mas adelante de todos modos. Además,
es muy probable que una meticulosa fase de diseño introduzca
complejidades que usted nunca necesitará, porque los escenarios
que ha preparado no suceden nunca.

\end{aosabox}

%In addition to the MediaService itself, there are two other interfaces
%that are particularly important: MediaDevice and MediaStream.
Además del propio Mediaservice, hay dos interfaces que son particularmente
importantes: MediaDevice y MediaStream.

%\begin{aosasect2}{Capture, Streaming, and Playback}
\begin{aosasect2}{Captura, Trasmision y Reproducción}

%MediaDevices represent the capture and playback devices that we use
%during a call (\aosafigref{fig.jit.media}). Your microphone and
%speakers, your headset and your webcam are all examples of such
%MediaDevices, but they are not the only ones.  Desktop streaming and
%sharing calls in Jitsi capture video from your desktop, while a
%conference call uses an AudioMixer device in order to mix the audio we
%receive from the active participants. In all cases, MediaDevices
%represent only a single MediaType. That is, they can only be either
%audio or video but never both. This means that if, for example, you
%have a webcam with an integrated microphone, Jitsi sees it as two
%devices: one that can only capture video, and another one that can
%only capture sound.
MediaDevices representa los dispositivos de captura y reproducción
que nosotros usamos durante una llamada (\aosafigref{fig.jit.media}).
Tu micrófono y altavoces, tus auriculares y tu webcam son todos ejemplos
de tales MediaDevices, pero no son los únicos. El escritorio
compartido y el intercambio de llamadas en Jitsi capturan vídeo desde tu
escritorio, mientras una llamada de conferencia usa un dispositivo AudioMixer para
mezclar el audio que nosotros recibimos de los participantes activos.
En todos los casos, MediaDevices representa un único MediaType. Es decir,
ellos pueden ser de audio o de vídeo pero nunca ambos a la vez. Esto
significa que si, por ejemplo usted tiene una webcam con un micrófono
integrado, Jisi lo interpreta como dos dispositivos: uno que únicamente
puede capturar vídeo, y otro que solo puede capturar sonido.

%Devices alone, however, are not enough to make a phone or a video
%call.  In addition to playing and capturing media, one has to also be
%able to send it over the network. This is where MediaStreams come
%in. A MediaStream interface is what connects a MediaDevice to your
%interlocutor. It represents incoming and outgoing packets that you
%exchange with them within a call.
Sin embargo, únicamente los dispositivos no son suficientes para hacer una
llamada telefónica o una vídeo llamada. Además para la reproducción y 
la captura, también es necesario ser capaces de enviar a través de la red.
Y aquí es donde llega MediaStream. Una interfaz MediaStream es la que
conecta un MediaDevice a su interlocutor. Representa los paquetes entrantes
y salientes que usted intercambia dentro de una llamada.

%Just as with devices, one stream can be responsible for only one
%MediaType. This means that in the case of an audio/video call Jitsi
%has to create two separate media streams and then connect each to the
%corresponding audio or video MediaDevice.
Al igual que con los dispositivos, un stream puede ser responsable de un
único MediaType. Esto significa que en el caso de una audio/vídeo llamada
Jitsi crea dos streams de comunicación separados y conecta cada uno a el
correspondiente audio o vídeo MediaDevice.

\aosafigureTop{../images/jitsi/Media.eps}{Media Streams For Different Devices}{fig.jit.media}

\end{aosasect2}

%\begin{aosasect2}{Codecs}
\begin{aosasect2}{Codecs}

%Another important concept in media streaming is that of MediaFormats,
%also known as codecs. By default most operating systems let you
%capture audio in 48KHz PCM or something similar.  This is what we
%often refer to as ``raw audio'' and it's the kind of audio you get in
%WAV files: great quality and enormous size. It is quite impractical to
%try and transport audio over the Internet in the PCM format.
Otro concepto importante en la transmisión de comunicación es el de
MediaFormats, también conocidos como codecs. Por defecto la mayoría
de sistemas operativos le dejan a usted capturar audio en 48KHz PCM
o algo similar. Esto es lo que a menudo se conoce como "audio en bruto",
y es el tipo de audio que se recibe en arhivos WAV: gran calidad
y enorme tamaño. Es poco practico transportar audio por Internet
en formato PCM.

%This is what codecs are for: they let you present and transport audio
%or video in a variety of different ways.  Some audio codecs like iLBC,
%8KHz Speex, or G.729, have low bandwidth requirements but sound
%somewhat muffled.  Others like wideband Speex and G.722 give you great
%audio quality but also require more bandwidth. There are codecs that
%try to deliver good quality while keeping bandwidth requirements at a
%reasonable level.  H.264, the popular video codec, is a good example
%of that. The trade-off here is the amount of calculation required
%during conversion. If you use Jitsi for an H.264 video call you see a
%good quality image and your bandwidth requirements are quite
%reasonable, but your CPU runs at maximum.
Esta son las tareas de los codecs: le permiten presentar y transportar
audio en una variedad de caminos diferentes. Algunos codecs de audio
como iLBC, 8KHz Speex, o G.729, tienen bajo requerimiento de ancho de
banda pero el sonido es un poco apagado. Otros de banda ancha como
Speex y G.7222 te proporcionan gran calidad de audio pero también requieren
mas ancho de banda. Hay codecs que intentan ofrecer buena calidad
mientras mantienen los requerimientos de ancho de banda en un nivel
razonable. H.264, el popular codec de vídeo, es un buen ejemplo de ello.
El compromiso aquí es la cantidad de cálculos requeridos durante la conversión.
Si usted usa Jitsi para una H.264 video llamada, verá una buena calidad
de imagen y los requerimientos de ancho de banda serán bastante razonables, pero
su CPU trabajará al máximo.

%All this is an oversimplification, but the idea is that codec choice
%is all about compromises. You either sacrifice bandwidth, quality, CPU
%intensity, or some combination of those. People working with VoIP
%rarely need to know more about codecs.
Todo es es una simplificación, pero la idea es que la elección del codec
sea un compromiso. Usted debe sacrificar ancho de banda, calidad, CPU, o alguna
combinación de de ellos. La gente que trabaja con VoIP raramente necesita saber
mas acerca de codecs.

\end{aosasect2}

%\begin{aosasect2}{Connecting with the Protocol Providers}
\begin{aosasect2}{Conectando con los proveedores de protocolo}

%Protocols in Jitsi that currently have audio/video support all use our
%MediaServices exactly the same way. First they ask the MediaService
%about the devices that are available on the system:
En Jitsi los todos protocolos que actualmente tiene soporte de audio/video
usan MediaService exactamente de la misma forma. Primero interrogan a MediaService
acerca de los dispositivos que estan disponibles en el sistema:

\begin{verbatim}
public List<MediaDevice> getDevices(MediaType mediaType, MediaUseCase useCase);
\end{verbatim}

%\noindent The MediaType indicates whether we are interested in audio or video
%devices. The MediaUseCase parameter is currently only considered in
%the case of video devices. It tells the media service whether we'd
%like to get devices that could be used in a regular call
%(MediaUseCase.CALL), in which case it returns a list of available
%webcams, or a desktop sharing session (MediaUseCase.DESKTOP), in which
%case it returns references to the user desktops.
\noindent El MediaType nos indica si estamos interactuando con un dispositivo
de audio o de vídeo. El parámetro MediaUseCase solo se tiene
en cuenta para el caso de dispositivos de vídeo. El le indica
al servicio de comunicación si nosotros deseamos obtener dispositivos
que puedan ser utilizados en una llamada regular (MediaUseCase.CALL),
en cuyo caso nos devuelve una lista de webcams disponibles,
o una sesión de escritorio compartido (MediaUseCase.DESKTOP),
en cuyo caso nos devuelve una referencia al escritorio de usuario.

%The next step is to obtain the list of formats that are available for
%a specific device. We do this through the
%\code{MediaDevice.getSupportedFormats} method:
El siguiente paso es obtener la lista de formatos que están disponibles
para el dispositivo especifico. Nosotros hacemos esto a través de el
método \code{MediaDevice.getSupportedFormats}:

\begin{verbatim}
public List<MediaFormat> getSupportedFormats();
\end{verbatim}

%\noindent Once it has this list, the protocol implementation sends it to the
%remote party, which responds with a subset of them to indicate which
%ones it supports. This exchange is also known as the Offer/Answer
%Model and it often uses the Session Description Protocol or some form
\noindent Una vez que esto esta listo, la implementación del protocolo lo
envía a la parte remota, que responde con un subconjunto del mensaje para
indicar si los apoya. Este intercambio también se conoce como
Modelo Oferta/Demanda y a menudo utiliza el Session Description Protocol
o alguna de sus formas.

%After exchanging formats and some port numbers and IP addresses, VoIP
%protocols create, configure and start the MediaStreams. Roughly
%speaking, this initialization is along the following lines:
Después de intercambiar algunos formatos, números de puerto,
direcciones IP, protocolos de creación VoIP, se configura y ejecuta
los MediaStreams. En términos generales, esta inicialización tiene el
siguiente aspecto:

\begin{verbatim}
// first create a stream connector telling the media service what sockets
// to use when transport media with RTP and flow control and statistics
// messages with RTCP
StreamConnector connector =  new DefaultStreamConnector(rtpSocket, rtcpSocket);
MediaStream stream = mediaService.createMediaStream(connector, device, control);

// A MediaStreamTarget indicates the address and ports where our
// interlocutor is expecting media. Different VoIP protocols have their
// own ways of exchanging this information
stream.setTarget(target);

// The MediaDirection parameter tells the stream whether it is going to be
// incoming, outgoing or both
stream.setDirection(direction);

// Then we set the stream format. We use the one that came
// first in the list returned in the session negotiation answer.
stream.setFormat(format);

// Finally, we are ready to actually start grabbing media from our
// media device and streaming it over the Internet
stream.start();
\end{verbatim}

%\noindent Now you can wave at your webcam, grab the mic and say, ``Hello
%world!''
\noindent Ahora usted puede saludar a la webcam mientras agarra el micrófono
y dice, ``Hola mundo!''

\end{aosasect2}

\end{aosasect1}

%\begin{aosasect1}{UI Service}
\begin{aosasect1}{Servicio de UI}

%So far we have covered parts of Jitsi that deal with protocols,
%sending and receiving messages and making calls. Above all, however,
%Jitsi is an application used by actual people and as such, one of its
%most important aspects is its user interface. Most of the time the
%user interface uses the services that all the other bundles in Jitsi
%expose. There are some cases, however, where things happen the other
%way around.
Hasta ahora hemos cubierto las partes de Jitsi que se ocupan de los
protocolos, enviar y recibir mensajes y realizar llamadas.
Sin embargo, Jitsi es por encima de todo una aplicación usada
por personas y como tal, uno de sus aspectos mas importantes
es su interfaz de usuario. La mayor parte del tiempo la interfaz de
usuario utiliza los servicios que el resto de bundles de Jisti proporcionan.
Sin embargo, hay algunos casos, donde las cosas suceden de otra manera.

%Plugins are the first example that comes to mind. Plugins in Jitsi
%often need to be able to interact with the user. This means they have
%to open, close, move or add components to existing windows and panels
%in the user interface. This is where our UIService comes into play. It
%allows for basic control over the main window in Jitsi and this is how
%our icons in the Mac OS X dock and the Windows notification area let
%users control the application.
Los plugins son el primer ejemplo que me viene a la mente. Los plugins en
Jitsi a menudo necesitan ser capaces de interactuar con el usuario.
Esto significa que tienen que abrir, cerrar, mover o añadir componentes
a las ventanas y paneles existentes en la interfaz de usuario. Aquí es
donde nuestro UIService entra en juego. Permitiendo un control básico
de la ventana principal de Jitsi y así es como nuestros iconos en el
Dock de Mac OS X y el área de notificación de Windows permiten a los
usuarios el control de la aplicación.

%In addition to simply playing with the contact list, plugins can also
%extend it. The plugin that implements support for chat encryption
%(OTR) in Jitsi is a good example for this. Our OTR bundle needs to
%register several GUI components in various parts of the user
%interface. It adds a padlock button in the chat window and a
%sub-section in the right-click menu of all contacts.
Además de manejar la lista de contactos, los plugins permiten también
su extensión. Los plugins que implementan soporte para 
el cifrado de chat (OTR) en Jitsi son un buen ejemplo de esto.
Nuestro bundle OTR necesita registrar varios componentes GUI
en varias partes de la interfaz de usuario. Añade un botón de
candado en la ventana de chat y una sub-seccion en el menú
del botón derecho del ratón sobre todos los contactos.

%The good news is that it can do all this with just a few method calls.
%The OSGi activator for the OTR bundle, OtrActivator, contains the
%following lines:
La buena noticia es que se puede hacer todo esto con solo unas pocas
llamadas a métodos. El activador OSGi para el bundle OTR, OtrActivator,
contiene las siguientes lineas:

\begin{verbatim}
Hashtable<String, String> filter = new Hashtable<String, String>();

// Register the right-click menu item.
filter(Container.CONTAINER_ID,
    Container.CONTAINER_CONTACT_RIGHT_BUTTON_MENU.getID());

bundleContext.registerService(PluginComponent.class.getName(),
    new OtrMetaContactMenu(Container.CONTAINER_CONTACT_RIGHT_BUTTON_MENU),
    filter);

// Register the chat window menu bar item.
filter.put(Container.CONTAINER_ID,
           Container.CONTAINER_CHAT_MENU_BAR.getID());

bundleContext.registerService(PluginComponent.class.getName(),
           new OtrMetaContactMenu(Container.CONTAINER_CHAT_MENU_BAR),
           filter);
\end{verbatim}

%As you can see, adding components to our graphical user interface
%simply comes down to registering OSGi services. On the other side of
%the fence, our UIService implementation is looking for implementations
%of its PluginComponent interface. Whenever it detects that a new
%implementation has been registered, it obtains a reference to it and
%adds it to the container indicated in the OSGi service filter.
Como puedes ver, añadir componentes a nuestra interfaz gráfica de usuario
simplemente se reduce a registrar servicios OSGi. En el otro lado de la valla,
nuestra implementación del UIService esta buscando implementaciones de la interfaz
PluginComponent. Cada vez que detecta que una nueva implementación nueva ha sido
registrada, se obtiene una referencia a ella y lo añade al contenedor adecuado
en el servicio de filtro OSGi.

%Here's how this happens in the case of the right-click menu
%item. Within the UI bundle, the class that represents the right click
%menu, MetaContactRightButtonMenu, contains the following lines:
Aquí vemos como sucede esto en el caso del menú del botón derecho del ratón.
Dentro del bundle UI, la clase que representa el menú del botón derecho del ratón,
MetaContactRightButtonMenu, contiene las siguientes lineas:

\begin{verbatim}
// Search for plugin components registered through the OSGI bundle context.
ServiceReference[] serRefs = null;

String osgiFilter = "("
    + Container.CONTAINER_ID
    + "="+Container.CONTAINER_CONTACT_RIGHT_BUTTON_MENU.getID()+")";

serRefs = GuiActivator.bundleContext.getServiceReferences(
        PluginComponent.class.getName(),
        osgiFilter);
// Go through all the plugins we found and add them to the menu.
for (int i = 0; i < serRefs.length; i ++)
{
    PluginComponent component = (PluginComponent) GuiActivator
        .bundleContext.getService(serRefs[i]);

    component.setCurrentContact(metaContact);

    if (component.getComponent() == null)
        continue;

    this.add((Component)component.getComponent());
}
\end{verbatim}

%\noindent And that's all there is to it. Most of the windows that you see within
%Jitsi do exactly the same thing: They look through the bundle context
%for services implementing the PluginComponent interface that have a
%filter indicating that they want to be added to the corresponding
%container.  Plugins are like hitch-hikers holding up signs with the
%names of their destinations, making Jitsi windows the drivers who pick
%them up.
\noindent Y esto es todo lo que hay que hacer. La mayoría de las ventanas
que se ven en Jitsi hacen exactamente lo mismo: buscar a través del contexto del bundle,
servicios que implementen el interfaz PluginComponent que tienen un filtro indicando
que ellos quieren ser añadidos al correspondiente contenedor. Los plugins son como
los autoestopistas, tienen letreros con los nombres de sus destinos, convirtiendo
a las ventanas de Jitsi en los conductores que los recogen.

\end{aosasect1}

%\begin{aosasect1}{Lessons Learned}
\begin{aosasect1}{Lecciones Aprendidas}

%When we started work on SIP Communicator, one of the most common
%criticisms or questions we heard was: ``Why are you using Java? Don't
%you know it's slow? You'd never be able to get decent quality for
%audio/video calls!'' The ``Java is slow'' myth has even been repeated
%by potential users as a reason they stick with Skype instead of trying
%Jitsi. But the first lesson we've learned from our work on the project
%is that efficiency is no more of a concern with Java than it would
%have been with C++ or other native alternatives.
Cuando nosotros comenzamos a trabajar con SIP Communicator, una de las
preguntas o criticas que mas escuchamos fue: ``¿Por que usáis Java? ¿No
sabéis que es lento? Nunca seréis capaces de conseguir un calidad decente
en las audio/vídeo llamadas!'' El mito de ``Java es lento'' se ha incluso
repetido por usuarios potenciales como una razón por la que seguir con Skype
en lugar de probar Jitsi. Pero la primera lección que hemos aprendido a través
de nuestro trabajo en el proyecto es que la eficiencia no es un tema que requiera
una mayor preocupación en Java de la que hubiera sido necesaria con C++ u otros
alternativas nativas.

%We won't pretend that the decision to choose Java was the result of
%rigorous analysis of all possible options. We simply wanted an easy
%way to build something that ran on Windows and Linux, and Java and the
%Java Media Framework seemed to offer one relatively easy way of doing
%so.
No pretendimos que la decisión de elegir Java fuera el resultado de un
riguroso análisis de todas las posibles opciones. Nosotros simplemente
queríamos un camino fácil para construir algo que se ejecutara en Windows
y Linux, y Java y el Java Media Framework parecía ofrecernos un camino
relativamente fácil para lograrlo.

%Throughout the years we haven't had many reasons to regret this
%decision.  Quite the contrary: even though it doesn't make it
%completely transparent, Java does help portability and 90\% of the code
%in SIP Communicator doesn't change from one OS to the next. This
%includes all the protocol stack implementations (e.g.,  SIP, XMPP, RTP,
%etc.) that are complex enough as they are. Not having to worry about
%OS specifics in such parts of the code has proven immensely useful.
A lo largo de los años no hemos tenido muchas razones para arrepentirnos
de esta decisión. Muy al contrario: a pesar de que no lo hace totalmente de
forma transparente, Java proporciona portabilidad y el 90\% del código en
SIP Communicator no cambia de un sistema operativo a otro. Esto incluye
todas las implementaciones de la pila de protocolos (e.g., SIP, XMPP, RTP, etc.)
que son lo suficientemente complejos como deberían. No tenernos que preocupar
acerca de las especificaciones del sistema operativo en cada parte del código
a resultado inmensamente útil.

%Furthermore, Java's popularity has turned out to be very important
%when building our community. Contributors are a scarce resource as it
%is.  People need to like the nature of the application, they need to
%find time and motivation---all of this is hard to muster. Not
%requiring them to learn a new language is, therefore, an advantage.
Además, la popularidad de Java se volvió muy importante cuando estábamos
construyendo nuestra comunidad. Los contribuidores son un recurso
escaso. La gente necesita sentirse a gusto con la naturaleza de la
aplicación, ellos necesitan tiempo y motivación---todo esto es difícil de
reunir. Que no les implique tener que aprender un nuevo lenguaje
es, además, una ventaja.

%Contrary to most expectations, Java's presumed lack of speed has
%rarely been a reason to go native. Most of the time decisions to use
%native languages were driven by OS integration and how much access
%Java was giving us to OS-specific utilities.  Below we discuss
%the three most important areas where Java fell short.
De forma contraria a la mayoría de las expectativas, la presunta falta
de velocidad de Java raramente ha sido una razón para optar por una
solución nativa. La mayoría de las veces las decisiones de usar un
lenguajes nativos fueron impulsadas por la intengración con sistemas
operativos y el acceso que Java nos estaba proporcionando a las
utilidades especificas de los sistemas operativos. A continuación se
analizan las tres áreas más importantes donde Java se quedó corto.

\begin{aosasect2}{Java Sound vs.\ PortAudio}

%Java Sound is Java's default API for capturing and playing audio. It
%is part of the runtime environment and therefore runs on all the
%platforms the Java Virtual Machine comes for. During its first years
%as SIP Communicator, Jitsi used JavaSound exclusively and this
%presented us with quite a few inconveniences.
Java Sound es la API por defecto de Java para la captura y reproducción
de audio. Es parte de le entorno de ejecución y por lo tanto
corre en todos las plataformas soportadas por la Java Virtual Machine.
Durante los primeros años de SIP Communicator, Jitsi uso JavaSound
exclusivamente y esto nos supuso unos pocos inconvenientes.

%First of all, the API did not give us the option of choosing which
%audio device to use. This is a big problem. When using their computer
%for audio and video calls, users often use advanced USB headsets or
%other audio devices to get the best possible quality. When multiple
%devices are present on a computer, JavaSound routes all audio through
%whichever device the OS considers default, and this is not good enough
%in many cases. Many users like to keep all other applications running
%on their default sound card so that, for example, they could keep
%hearing music through their speakers. What's even more important is
%that in many cases it is best for SIP Communicator to send audio
%notifications to one device and the actual call audio to another,
%allowing a user to hear an incoming call alert on their speakers even
%if they are not in front of the computer and then, after picking up
%the call, to start using a headset.
Para empezar, la API no nos da opción de elegir que dispositivo de audio
usar. Esto es un gran problema. Cuando los usuarios usan su computadora
para realizar llamadas de audio y vídeo, a menudo utilizan avanzados auriculares
USB u otros dispositivos de audio para conseguir la mejor calidad posible.
Cuando se conectan al computador múltiples dispositivos, JavaSound dirige
todo el audio a través del dispositivo que el OS considere por defecto,
y esto no es bueno en muchos casos. A muchos usuarios les gusta tener otras
otras aplicaciones ejecutándose sobre su tarjeta de sonido, por ejemplo,
ellos podrían estar escuchando musica a través de sus altavoces. Lo que es
aun mas importante es que en muchos casos es mejor para SIP Communicator
enviar notificaciones de audio a un dispositivo y la actual llamada de audio
a otro, permitiendo al usuario escuchar una alerta de llamada entrante en sus
altavoces incluso si no están frente al computador, para entonces, coger la
llamada, y comenzar a usar unos auriculares.

%None of this is possible with Java Sound. What's more, the Linux
%implementation uses OSS which is deprecated on most of today's Linux
%distributions.
Nada de esto es posible con Java Sound. Es mas, la implementación para Linux
usa OSS, el cual esta deprecado en la mayoría de las distribuciones de Linux de
hoy en día.

%We decided to use an alternative audio system. We didn't want to
%compromise our multi-platform nature and, if possible, we wanted to
%avoid having to handle it all by ourselves. This is where 
%PortAudio\footnote{\url{http://portaudio.com/}} came in extremely handy.
Decidimos por lo tanto, usar un sistema de audio alternativo. No queríamos
comprometer nuestra naturaleza multi-plataforma, y si era posible, queríamos
evitar tener que manejar todo nosotros mismos. Aquí fue donde
PortAudio\footnote{\url{http://portaudio.com/}} nos fue extremadamente practico.

%When Java doesn't let you do something itself, cross-platform open
%source projects are the next best thing. Switching to PortAudio has
%allowed us to implement support for fine-grained configurable audio
%rendering and capture just as we described it above. It also runs on
%Windows, Linux, Mac OS X, FreeBSD and others that we haven't had the
%time to provide packages for.
Cuando Java no te permite realizar algo, los proyectos de código abierto
multi-plataforma son la siguiente mejor opción. Cambiar a PortAudio nos
permitió implementar soporte para una configuración de reproducción audio
de grano fino y capturar de igual forma que describimos anteriormente.
También se ejecuta sobre Windows, Linux, Mac OS X, FreeBSD y otros para
los cuales no hemos tenido tiempo de proporcionar paquetes.

\end{aosasect2}

%\begin{aosasect2}{Video Capture and Rendering}
\begin{aosasect2}{Captura de Video y Renderizado}

%Video is just as important to us as audio. However, this didn't seem
%to be the case for the creators of Java, because there is no default
%API in the JRE that allows capturing or rendering video. For a while
%the Java Media Framework seemed to be destined to become such an API
%until Sun stopped maintaining it.
El vídeo es tan importante para nosotros como el audio. Sin embargo,
este no parece ser el caso para los creadores de Java, porque no hay una
API por defecto en la JRE que permita capturar o renderizar vídeo.
Durante un tiempo el Java Media Framework parecía estar destinado a
convertirse en dicha API hasta que Sun detuvo su mantenimiento.

%Naturally we started looking for a PortAudio-style video alternative,
%but this time we weren't so lucky. At first we decided to go with the
%LTI-CIVIL framework from Ken
%Larson\footnote{\url{http://lti-civil.org/}}. This is a wonderful
%project and we used it for quite a while\footnote{Actually we still have it as
%a non-default option.}. However it turned out to be suboptimal
%when used in a real-time communications context.
Naturalmente comenzamos a buscar una alternativa del estilo de PortAudio,
pero esta vez no tuvimos tanta suerte. En un primer momento decidimos
utilizar el framework LTI-CIVIL de Ken Larson\footnote{\url{http://lti-civil.org/}}.
Es un proyecto maravilloso y lo utilizamos desde hace bastante
tiempo\footnote{Actualmente la mantenemos como una opción no usada
por defecto}. Sin embargo, resulto no ser óptimo cuando se utiliza
en un contexto de comunicaciones en tiempo real.

%So we came to the conclusion that the only way to provide impeccable
%video communication for Jitsi would be for us to implement native
%grabbers and renderers all by ourselves. This was not an easy decision
%since it implied adding a lot of complexity and a substantial
%maintenance load to the project but we simply had no choice: we really
%wanted to have quality video calls. And now we do!
Así llegamos a la conclusión de que la única manera de proporcionar una
comunicación de vídeo impecable por Jitsi seria implementar capturadores
nativos y realizar el abanderizado nosotros mismos. Esta no fue una fácil decisión ya que implica añadir una gran complejidad y una sustancial carga mantenimiento para el proyecto, pero simplemente no teníamosotra opción: realmente queríamos tener llamadas de vídeo de
calidad. Y ahora lo hacemos!

%Our native grabbers and renderers directly use Video4Linux 2, QTKit
%and DirectShow/Direct3D on Linux, Mac OS X, and Windows respectively.
Nuestros capturadores y renderizadores nativos usan directamente
Video4Linux 2, QTKit y DirectShow/Direct3D en Linux, Mac OS X,
y Windows respectivamente.

\end{aosasect2}

\begin{aosasect2}{Video Encoding and Decoding}

%SIP Communicator, and hence Jitsi, supported video calls from its
%first days. That's because the Java Media Framework allowed encoding
%video using the H.263 codec and a 176x144 (CIF) format.  Those of you
%who know what H.263 CIF looks like are probably smiling right now; few
%of us would use a video chat application today if that's all it had to
%offer.
SIP Communicator, y por lo tanto Jitsi, soportaron llamadas de vídeo
desde sus primeros días. La razón fue que el Java Media Framework
permitía codificar vídeo usando el codec H.263 y un formato 176x144 (CIF).
Aquellos de ustedes que conocen H.263 CIF puede que estén
sonriendo en este momento; probablemente, pocos de nosotros
querríamos usar hoy una aplicación de vídeo chat, si eso es
todo lo que tiene que ofrecer.

%In order to offer decent quality we've had to use other libraries like
%FFmpeg. Video encoding is actually one of the few places where Java
%shows its limits performance-wise. So do other languages, as evidenced
%by the fact that FFmpeg developers actually use Assembler in a number
%of places in order to handle video in the most efficient way possible.
Con el objetivo de ofrecer una calidad decente hemos tenido que utilizar
otras librerías como FFmpeg. La codificación de vídeo es actualmente
un de los pocos lugares donde Java muestra limitaciones en cuanto a
rendimiento. Lo mismo ocurre con otros lenguajes, como lo demuestra el
hecho de que los desarrolladores de FFmpeg usen Ensamblador en ciertos
lugares con el fin de manejar el vídeo de la manera más eficiente posible.

\end{aosasect2}

\begin{aosasect2}{Others}

%There are a number of other places where we've decided that we needed
%to go native for better results. Systray notifications with Growl on
%Mac OS X and libnotify on Linux are one such example. Others include
%querying contact databases from Microsoft Outlook and Apple Address
%Book, determining source IP address depending on a destination, using
%existing codec implementations for Speex and G.722, capturing desktop
%screenshots, and translating chars into key codes.
Hay ciertas partes donde nosotros decidimos que necesitábamos utilizar
lenguajes nativos para mejorar los resultados. Las notificaciones de la
bandeja del sistema con Growl en Mac OS X y libnotify en Linux son un
ejemplo de ello. Otros son la consulta de la bases de datos de contactos
de Microsoft Outlook y el Apple Address Book, la determinación de la fuente
direcciones IP en función de un destino, el uso de implementaciones
existentes para los codecs Speedx y G.7222, las capturas de pantalla
y la traducción de caracteres a códigos de tecla.

\end{aosasect2}

%The important thing is that whenever we needed to choose a native
%solution, we could, and we did. This brings us to our point: Ever
%since we've started Jitsi we've fixed, added, or even entirely
%rewritten various parts of it because we wanted them to look, feel or
%perform better.  However, we've never ever regretted any of the things
%we didn't get right the first time. When in doubt, we simply picked
%one of the available options and went with it. We could have waited
%until we knew better what we were doing, but if we had, there
%would be no Jitsi today.
Lo importante es que cada vez que necesitamos elegir una solución nativa,
nosotros pudimos, y así lo hicimos. Esto nos lleva al punto: Desde que
comenzamos Jitsi hemos corregido, añadido, o incluso reescrito enteramente
varias partes de él porque queríamos una mejor apariencia o rendimiento.
Sin embargo, nunca hemos lamentado ninguna de las cosas que no conseguimos
a la primera. En caso de duda, simplemente se tomó una de las opciones
disponibles y se continuó con ella. Podríamos haber esperado hasta que
supiésemos mejor lo que estábamos haciendo, pero si lo hubiéramos hecho
así, hoy no tendríamos Jitsi.

\end{aosasect1}

%\begin{aosasect1}{Acknowledgments}
\begin{aosasect1}{Agradecimientos}

%Many thanks to Yana Stamcheva for creating all the diagrams in this
%chapter.
Muchas gracias a Yana Stamcheva por la creación de todos los diagramas
de este capítulo.

\end{aosasect1}

\end{aosachapter}
